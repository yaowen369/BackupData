# JVM讲课计划

[TOC]

# 走进java

+ Java不仅仅是一门编程语言，而是一个由一系列计算机软件和规范形成的技术体系，该技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统、移动终端、企业服务器、大型机等各种场合

### **java的优点：**
- Write Once，Run Anywhere。平台无关性。
- 结构严谨、面向对象,强类型编译型语言。
- 它提供了一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问题。
- 实现了热点代码检测和运行时编译及优化，这使得Java应用能随着运行时间的增加而获得更高的性能。
- 它有一套完善的应用程序接口。


### **java技术体系**
 **从广义上讲** ，Clojure、JRuby、Groovy,Scale等运行于Java虚拟机上的语言及其相关的程序都属于Java技术体系中的一员。
 
 **从传统意义来讲**，Sun官方所定义的Java技术体系包括以下几个组成部分。
 > + Java程序设计语言
 > + 各种硬件平台上的Java虚拟机
 > + Class文件格式
 > + Java API类库
 > + 来自商业机构和开源社区的第三方Java类库
 
 ![java技术体系结构.png-36.7kB](http://static.zybuluo.com/yaowen369/gwcd9voivsp17h1fnfb46h9s/java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)
  
  以上是根据各个组成部分的功能来进行划分的，如果按照技术所服务的领域（或者业务）来划分,可分为四个平台。
  
  
 * **Java Card：** 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。
 * **Java ME（Micro Edition）：** 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。
 * **Java SE（Standard Edition）：**支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，这个版本以前称为J2SE。
 * **Java EE（Enterprise Edition）：**支持使用多层架构的企业应用（如ERP、CRM应用）的Java平台，除了提供Java SE API外，还对其做了大量的扩充[3]并提供了相关的部署支持，这个版本以前称为J2EE。
 

### **java以及虚拟机发展历史**

![java发展历史.jpg-38.5kB](http://static.zybuluo.com/yaowen369/l122svl40vplb1op71rimub7/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.jpg)

 - [] 可以写一下更具体的信息，比如每个版本增加了什么。

 > + JDK 1.0 : 
 > + JDK 1.1 :   增加 JavaBeans、JDBC、RMI
 > + JDK 1.2 : 代号为Playground(竞技场)。增加 EJB、Java Plug-in、Java IDL、Swing
 > + JDK 1.3 : 代号为Kestrel（美洲红隼）。增加 HotSpot JVM、为了支持与CORBA的选择兼容性而修改了RMI、JNDI、JPDA
 > + JDK 1.4 : 代号为Merlin（灰背隼）。增加了 正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器
 > + JDK 1.5:代号Tiger（老虎）。语法易用性上做出了非常大的改进。例如，自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach循环）等语法特性。
> + JDK 6 : Mustang（野马）。改进包括：提供动态语言支持、提供编译API和微型HTTP服务器API。这个版本对Java虚拟机内部做了大量算法上的改进。
> + JDK 7 : 代号为Dolphin（海豚）。改进包括 压缩了 64 比特的指针、JSR 166下的并发实用工具、用于图形功能的新平台API、Java部署规则集
> + JDK 8 ：改进包括  lambda expressions、Nashorn、 注解、新的 日期和时间 API
> + JDK 9 : 2017年7月。改进包括  模块化 (Java Module System)、Java的Shell 、Ahead-of-Time Compilation、XML Catalogs。
 
 
1996年初Sun公司发布的JDK 1.0中所包含的Sun Classic VM到今天，曾经涌现、湮灭过许多或经典或优秀或有特色的虚拟机实现：

 历史上发布过虚拟机有:
 
 - Sun Classic/Exact VM
 - Sun HotSpot VM
 - Sun Mobile-Embedded VM/Meta-Circular VM
 - Sun KVM
 - Sun Squawk VM
 - BEA JRockit  (它们曾经自称“世界上速度最快的Java虚拟机”，不过J9VM也这样自称过)
 - IBM J9 VM
 - Azul VM
 - Apache Harmony
 - Google Android Dalvik VM
 - **Microsoft JVM**
 - Moxie JVM.
 - Jikes RVM.
 - Jelatine JVM.
 

可以运行在jvm之上的语言

![可以运行在jvm之上的语言.jpg-34.8kB](http://static.zybuluo.com/yaowen369/kqw2u4j99dwfn8g2xhw8qni9/%E5%8F%AF%E4%BB%A5%E8%BF%90%E8%A1%8C%E5%9C%A8jvm%E4%B9%8B%E4%B8%8A%E7%9A%84%E8%AF%AD%E8%A8%80.jpg)

  
   ---
#java内存区域

**java和c++之间有一堵由动态内存分配和垃圾收集技术所围成的'高墙'，墙外的人想进去，墙内的人想出来**

### **内存模型**

![jvm_2_memory_area_06.png-89.3kB](http://static.zybuluo.com/yaowen369/re7bww32fyjj84qao21po8ng/jvm_2_memory_area_06.png)

##### **程序计数器**
1. 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令


##### **虚拟机栈**
1. Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 栈帧是方法运行时的基础数据结构。


##### **本地方法栈**
1. 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。


##### **java堆**
1. 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配

##### **方法区**
1. 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。

#####  **运行时常量池**
1. 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

##### **直接内存**
1. 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。


 
###  **对象的访问定位**


 + 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如图所示。
 
![对象的访问定位-句柄.jpg-23kB](http://static.zybuluo.com/yaowen369/6ywvo4aw1wca25ftihxtrkmt/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E5%8F%A5%E6%9F%84.jpg)


  + 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如图2-3所示。
  
  ![对象的访问定位-指针.jpg-20.1kB](http://static.zybuluo.com/yaowen369/aobf8pcm78wje6rfvvzb79s0/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E6%8C%87%E9%92%88.jpg)


  ---
  
# 垃圾回收
 **垃圾收集（Garbage Collection,GC）**
 1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：
 > + 哪些内存需要回收？
 > + 什么时候回收？
 > + 如何回收？
 
### **哪些内存需要回收？**
 
##### **引用计数法**
 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
 
 应用案例：COM, FlashPlayer， Python语言
 
 **缺点：无法解决对象之间相互循环引用的问题。**
 
##### **可达性分析算法(Reachability Analysis)**
   *在主流的商用程序语言（Java、C#，Lisp）的主流实现中，都是通过该算法来判定对象是否存活的。*
   
 > 基本思路:通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。
 
 ![可达性分析.png-21kB](http://static.zybuluo.com/yaowen369/56gau6s88994ht8f0bm2und9/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png)
 
 
 在Java中，可作为GC Roots的对象包括下面几种：

> + 虚拟机栈（栈帧中的本地变量表）中引用的对象。
> + 方法区中类静态属性引用的对象。
> + 方法区中常量引用的对象。
> + 本地方法栈中JNI（即一般说的Native方法）引用的对象。


### **垃圾收集算法**
##### **标记-清除算法(Mark-Sweep)**

 ![gc标记-清除算法.png-67.8kB]( http://static.zybuluo.com/yaowen369/m7h0b77jwig1qqc3cp5iqgb4/gc%E6%A0%87%E8%AE%B0-%E6%B8%85%E6%A5%9A%E7%AE%97%E6%B3%95.png)

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
缺点：1.效率不高。2.产生内存碎片

##### **复制算法(Copying)**

![gc复制算法.png-30.3kB](http://static.zybuluo.com/yaowen369/wcxhpva13zp3tlhmvv9yw5bp/gc%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png)

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样不会产生内存碎片，分配新对象时，也只需要移动指针即可，实现简单，运行高效。

适合新生代的回收.

#####  **标记-整理算法(Mark-Compact)**
![gc标记-整理算法.png-39.2kB](http://static.zybuluo.com/yaowen369/jx3bd2ed6q3meixzorsdxai7/gc%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png)

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

适用于老年代的回收。

#####  **分代收集算法(Generational Collection)**
当前商业虚拟机的垃圾收集都采用“分代收集”算法，只是根据对象存活周期的不同将内存划分为几块。(一般把Java堆分为新生代和老年代)这样就可以根据各个年代的特点采用最适当的收集算法。

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

### **HotSpot算法实现与其垃圾收集器**
标记过程-枚举根节点过程中的碰到的问题。。
+ 如果逐个遍历GC Roots，太耗时.(使用OopMap的数据结构来存储)。
+ 所有线程必须有一个停顿过程。(Stop The World).
> 可达性分析必须在一个能确保一致性的快照中进行 --->>> 这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况。否则无法保证 分析结果的准确性。


### **垃圾收集器**
算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

![HotSpot的垃圾收集器.jpg-19.3kB](http://static.zybuluo.com/yaowen369/sorkf14kt70vyv8xcueiup1o/HotSpot%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg)

##### **CMS收集器**
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
特点：并发收集、低停顿,容易产生内存碎片.

![gc_CMS垃圾收集器.png-47.2kB](http://static.zybuluo.com/yaowen369/sx8sx3m35x3cl3jqun6plq92/gc_CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)


##### **G1收集器**
G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一.是一款面向服务端应用的垃圾收集器。

![gc_g1垃圾收集器.png-73.4kB](http://static.zybuluo.com/yaowen369/rlvf68lw93qn9bstyi40zo2m/gc_g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)


特点：

+ 并行与并发
+ 分代收集
+ 空间整合
+ 可预测的停顿
> 它能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。它可以有计划地避免在整个Java堆中进行全区域的垃圾收集,它将整个Java堆划分为多个大小相等的独立区域（Region）,每次根据允许的收集时间，优先回收价值最大的Region。

##### **虚拟机日志**

```
33.125：[GC[DefNew：3324K-＞152K（3712K），0.0025925 secs]3324K-＞152K（11904K），0.0031680 secs]

1 0 0.6 6 7：[F u l l G C[T e n u r e d：0 K-＞2 1 0 K（1 0 2 4 0 K），0.0 1 4 9 1 4 2 s e c s]4603K-＞210K（19456K），[Perm：2999K-＞2999K（21248K）]，0.0150007 secs][Times：user=0.01 sys=0.00，real=0.02 secs]


[Full GC 283.736：[ParNew：261599K-＞261599K（261952K），0.0000288 secs]
```

---
#Class文件

**代码编译的结果从本地机器码（NativeCode）转变为字节码(ByteCode)，是存储格式发展的一小步，却是编程语言发展的一大步。**


### **平台无关性 （中间件）**
Sun公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。

各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石。

### **语言无关性**

很多程序员都还认为Java虚拟机执行Java程序是一件理所当然和天经地义的事情。真是错误的。

在最初设计的时候就把Java的规范拆分成了Java语言规范《The Java Language Specification》及Java虚拟机规范《The Java Virtual Machine Specification》。

并且在1997年发布的第一版Java虚拟机规范中就曾经承诺过：“In the future,we will consider bounded extensions to the Java virtual machine to provide better support for other languages”（在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于JVM之上）。


时至今日,这个目标已经实现。涌现Clojure、Groovy、JRuby、Jython、Scala一批运行在java虚拟机上的语言。


实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。

Java,Scale等各种语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比单一语言本身更加强大。

![虚拟机提供的语言无关性.png-76.1kB](http://static.zybuluo.com/yaowen369/xfjw2nacjf4fs88kerc6im43/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8F%90%E4%BE%9B%E7%9A%84%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7.png)

### **Class文件结构**

任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在Class文件里（譬如类或接口也可以通过类加载器直接生成）。


Class文件是一组以8位字节为基础单位的、顺序严格的二进制流，中间没有添加任何分隔符或空隙，当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前（Big-Endian）的方式分割成若干个8位字节进行存储。

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础。

无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

![Class文件格式.png-143.8kB](http://static.zybuluo.com/yaowen369/wobpe0nruwonmmsl9mmiyje1/Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png)


Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在表6-1中的数据项，无论是顺序还是数量，甚至于数据存储的字节序这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。

魔数（Magic Number） CAFEBABE --->>> 次版本号（Minor Version） 和 主版本号 --->>> 常量池入口(Class文件的资源仓库)


![虚拟机字节码指令表.png-208.3kB](http://static.zybuluo.com/yaowen369/x9tcg31823xpahk31yffchbc/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E8%A1%A8.png)

---

#虚拟机类加载

虚拟机把类的描述数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。


与C语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时增加性能开销，但可以提供高度的灵活性。Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

> 例如，java应用程序可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络加载一个二进制流作为程序代码的一部分。从最基础的Applet、JSP到OSGi技术，都使用了Java语言运行期类加载的特性。

### **类加载的时机**

![类的生命周期.png-20.6kB](http://static.zybuluo.com/yaowen369/b686jwfm8nz7npixg8qpguut/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

##### **加载** 
加载”是“类加载”（Class Loading）过程的一个阶段(不要混淆这两个词)。该阶段完成三件事
> 1. 通过一个类的全限定名来获取定义此类的二进制字节流。
> 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
> 3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

关于第一条，没有指明要从哪里获取、怎样获取。所以这是一个可以自由发挥的舞台，许多Java技术都建立在这一基础之上。比如:
> + 从ZIP包中读取,(JAR、WAR格式).
> + 从网络中获取(Applet)
> + 运行时计算生成(动态代理技术，反射)
> + 从数据库中读取

##### **验证**
该阶段为了确保Class文件字节流的正确，确保其不会做出非法行为,避免虚拟机遭到恶意代码攻击。所以该过程工作量也较大。
 如果字节码没有通过字节码验证，那肯定是有问题的；但如果通过了字节码验证，也不能说明其绝对安全的。
 
##### **准备**
准备阶段是正式为类变量分配内存并将内存区域清空阶段(初始化为0)，这些变量所使用的内存都将在方法区中进行分配。此时内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

##### **解析**
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

##### **初始化**
类初始化阶段是类加载过程的最后一步,该阶段真正开始执行类中定义的Java程序代码（或者说是字节码）。

该阶段是通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞（）方法的过程。

###### **关于＜clinit＞**
＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，它与类的构造函数（或者说实例构造器＜init＞（）方法）不同，它不需要显式地调用父类构造器，虚拟机会保证父类构造器先执行。


#### **类加载器**

虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

类加载器起到的作用不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

这里所指的“相等”，包括代表类的Class对象的equals（）方法、instanceof关键字等。


##### **双亲委派模型**


从Java开发人员的角度来看，类加载器分为三类
> 1. 启动类加载器（Bootstrap ClassLoader）
> 2. 扩展类加载器（Extension ClassLoader）
> 3. 应用程序类加载器（Application ClassLoader）也叫系统类加载器。


我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。

![类加载器双亲委派模型.png-36.7kB](http://static.zybuluo.com/yaowen369/os7xstpernit5029rvzp9wr4/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png)

双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。


双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

# 虚拟机字节码执行引擎
执行引擎是Java虚拟机最核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系。 

在虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

### **运行时栈结构**
栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

一个栈帧需要多大内存，在编译代码的时候就已经确定了。

![栈帧的概念结构.png-24.5kB](http://static.zybuluo.com/yaowen369/kholafsg9xqy7qol2lz0cv04/%E6%A0%88%E5%B8%A7%E7%9A%84%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84.png)

##### **局部变量表**
局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

##### **操作数栈**
Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。
举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。

##### **动态连接**

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。

##### **方法返回地址**


### **方法调用**

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

##### **解析**

所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类。


##### **分派**

```java
/**
*方法静态分派演示
*@author zzm
*/
public class StaticDispatch{
	static abstract class Human{
	}
	static class Man extends Human{
	}
	static class Woman extends Human{
	}	
	
	public void sayHello（Human guy）{
		System.out.println（"hello,guy！"）；
	}
	
	public void sayHello（Man guy）{
		System.out.println（"hello,gentleman！"）；
	}
	public void sayHello（Woman guy）{
		System.out.println（"hello,lady！"）；
	}
	public static void main（String[]args）{
		Human man=new Man（）；
		Human woman=new Woman（）；
		StaticDispatch sr=new StaticDispatch（）；
		sr.sayHello（man）；
		sr.sayHello（woman）；
	}
}
```

运行结果:
```
hello,guy！
hello,guy！
```

原因解释:

     Human man=new Man（）； 

我们把上面代码中的“Human”称为变量的静态类型（Static Type），或者叫做的外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

```java
//实际类型变化
Human man=new Man（）；
man=new Woman（）；
//静态类型变化
sr.sayHello（（Man）man）
sr.sayHello（（Woman）man）
```

解释了这两个概念，样例代码中。main（）里面的两次sayHello（）方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。代码中刻意地定义了两个静态类型相同但实际类型不同的变量，但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello（Human）作为调用目标。


所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。这种模糊的结论在由0和1构成的计算机世界中算是比较“稀罕”的事情，产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断。下面的代码清单演示了何为“更加合适的”版本。
    
```java
public class Overload{
	public static void sayHello（Object arg）{
		System.out.println（"hello Object"）；
	}
	public static void sayHello（int arg）{
		System.out.println（"hello int"）；
	}
	public static void sayHello（long arg）{
		System.out.println（"hello long"）；
	}
	public static void sayHello（Character arg）{
		System.out.println（"hello Character"）；
	}
	public static void sayHello（char arg）{
		System.out.println（"hello char"）；
	}
	public static void sayHello（char……arg）{
		System.out.println（"hello char……"）；
	}
	public static void sayHello（Serializable arg）{
		System.out.println（"hello Serializable"）；
	}
	public static void main（String[]args）{
		sayHello（'a'）；
	}
}
```

运行结果 `hello char`,
注释到 `ayHello（char arg）`，输出`hello int`(自动类型转换)。
依次注释，会输出 `hello Character`(自动装箱) ->  `hello Serializable`(装箱类的接口) -> `hello Object`(向上转型)  -> `hello char……`(被当成数组元素)

演示了编译期间选择静态分派目标的过程，这个过程也是Java语言实现方法重载的本质。


##### **动态分配**

```java
public class DynamicDispatch{
	static abstract class Human{
		protected abstract void sayHello（）；
	}
	
	static class Man extends Human{
		@Override
		protected void sayHello（）{
			System.out.println（"man say hello"）；
		}
	}
	
	static class Woman extends Human{
		@Override
		protected void sayHello（）{
			System.out.println（"woman say hello"）；
		}
	}
	
	public static void main（String[]args）{
		Human man=new Man（）；
		Human woman=new Woman（）；
		man.sayHello（）；
		woman.sayHello（）；
		man=new Woman（）；
		man.sayHello（）；
	}
}
```

运行结果：
```
man say hello
woman say hello
woman say hello
```


##### **基于栈的字节码解释执行引擎**
Java编译器输出的指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture,ISA），指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，说得通俗一些，就是现在我们主流PC机中直接支持的指令集架构，这些指令依赖寄存器进行工作。那么，基于栈的指令集与基于寄存器的指令集这两者之间有什么不同呢？

举个最简单的例子，分别使用这两种指令集计算“1+1”的结果，基于栈的指令集会是这样子的：

```
iconst_1
iconst_1
iadd
istore_0
```
两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个Slot中。


如果基于寄存器，那程序可能会是这个样子：
```
mov eax，1
add eax，1
```

mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。

基于栈的指令集主要的优点就是可移植，但是速度较慢。


也有基于寄存器的虚拟机，如Google Android平台的Dalvik VM。即使是基于寄存器的虚拟机，也希望把虚拟机寄存器尽量映射到物理寄存器上以获取尽可能高的性能。

---

# 程序编译与代码优化

*从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。*

Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器把*.java文件转变成*.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程；还可能是指使用静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码的过程。

1. 前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。
2. JIT编译器：HotSpot VM的C1、C2编译器。
3. AOT编译器：GNU Compiler for the Java（GCJ）[2]、Excelsior JET。

### **晚期（运行期）优化**
在部分的商用虚拟机中，Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，下文中简称JIT编译器）。


许多主流的商用虚拟机都同时包含解释器与编译器。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。

# 高效并发

*并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。*


Amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力，摩尔定律则用于描述处理器晶体管数量与运行效率之间的发展关系。这两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核心并行处理的发展过程。

在许多情况下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘I/O、网络通信或者数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状态，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的浪费，而让计算机同时处理几项任务则是最容易想到、也被证明是非常有效的“压榨”手段。


###  **硬件的效率与一致性**
“让计算机并发执行若干个运算任务”与“更充分地利用计算机处理器的效能”之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），如图12-1所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。在本章中将会多次提到的“内存模型”一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。


![处理器、高速缓存、主内存间的交互关系.jpg-36.9kB](http://static.zybuluo.com/yaowen369/m58xrc986wbvez071drxggc2/%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.jpg)

